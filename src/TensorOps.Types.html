<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes     #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE ConstrainedClassMethods #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE ConstraintKinds         #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE DataKinds               #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts        #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances       #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE GADTs                   #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE InstanceSigs            #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE KindSignatures          #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase              #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses   #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE PolyKinds               #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes              #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables     #-}</span><span>
</span><a name="line-15"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving      #-}</span><span>
</span><a name="line-16"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications        #-}</span><span>
</span><a name="line-17"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies            #-}</span><span>
</span><a name="line-18"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilyDependencies  #-}</span><span>
</span><a name="line-19"></a><span class="hs-pragma">{-# LANGUAGE TypeInType              #-}</span><span>
</span><a name="line-20"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators           #-}</span><span>
</span><a name="line-21"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances    #-}</span><span>
</span><a name="line-22"></a><span class="hs-pragma">{-# LANGUAGE ViewPatterns            #-}</span><span>
</span><a name="line-23"></a><span>
</span><a name="line-24"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-25"></a><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Category</span><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">Primitive</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Finite</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Kind</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Length</span><span>                  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCL</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span>                 </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCP</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Product.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>            </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCP</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Sing.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Sing</span></a><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Uniform.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Uniform</span></a><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Prelude</span><span> </span><span class="hs-keyword">hiding</span><span>                    </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">.</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">id</span><span class="hs-special">)</span><span>
</span><a name="line-39"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Statistics</span><span class="hs-operator">.</span><span class="hs-identifier">Distribution</span><span>
</span><a name="line-40"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">Random</span><span class="hs-operator">.</span><span class="hs-identifier">MWC</span><span>
</span><a name="line-41"></a><span class="hs-keyword">import</span><span>           </span><a href="TensorOps.NatKind.html"><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">NatKind</span></a><span>
</span><a name="line-42"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Higher</span><span>
</span><a name="line-43"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Known</span><span>
</span><a name="line-44"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Witness</span><span>
</span><a name="line-45"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-46"></a><span>
</span><a name="line-47"></a><span class="hs-pragma">{-# RULES
&quot;realToFrac/Double-&gt;Double&quot; realToFrac = id :: Double -&gt; Double
&quot;realToFrac/Float-&gt;Float&quot; realToFrac = id :: Float -&gt; Float
    #-}</span><span>
</span><a name="line-51"></a><span>
</span><a name="line-52"></a><span class="hs-keyword">class</span><span> </span><a href="TensorOps.NatKind.html#NatKind"><span class="hs-identifier hs-type">NatKind</span></a><span> </span><a href="#local-1627754494"><span class="hs-identifier hs-type">k</span></a><span> </span><span class="hs-glyph">=&gt;</span><span> </span><a name="Tensor"><a href="TensorOps.Types.html#Tensor"><span class="hs-identifier">Tensor</span></a></a><span> </span><span class="hs-special">(</span><a name="local-1627754495"><a href="#local-1627754495"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><a href="#local-1627754494"><span class="hs-identifier hs-type">k</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-53"></a><span>    </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">ElemT</span><span> </span><a name="local-1627754495"><a href="#local-1627754495"><span class="hs-identifier">t</span></a></a><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-54"></a><span>
</span><a name="line-55"></a><span>    </span><span class="hs-comment">-- TODO: can we detach Vec from liftT ?</span><span>
</span><a name="line-56"></a><span>    </span><span class="hs-identifier">liftT</span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><a href="#local-1627754496"><span class="hs-identifier hs-type">o</span></a><span>
</span><a name="line-57"></a><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Vec</span><span> </span><a href="#local-1627754497"><span class="hs-identifier hs-type">n</span></a><span> </span><span class="hs-special">(</span><a href="TensorOps.Types.html#ElemT"><span class="hs-identifier hs-type">ElemT</span></a><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="TensorOps.Types.html#ElemT"><span class="hs-identifier hs-type">ElemT</span></a><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-58"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Vec</span><span> </span><a href="#local-1627754497"><span class="hs-identifier hs-type">n</span></a><span> </span><span class="hs-special">(</span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754496"><span class="hs-identifier hs-type">o</span></a><span class="hs-special">)</span><span>
</span><a name="line-59"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754496"><span class="hs-identifier hs-type">o</span></a><span>
</span><a name="line-60"></a><span>    </span><span class="hs-identifier">gmul</span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">SingI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Reverse</span><span> </span><a href="#local-1627754498"><span class="hs-identifier hs-type">os</span></a><span> </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754499"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><span class="hs-special">(</span><a href="#local-1627754500"><span class="hs-identifier hs-type">ms</span></a><span> </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754499"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-61"></a><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier hs-type">Length</span><span> </span><a href="#local-1627754500"><span class="hs-identifier hs-type">ms</span></a><span>
</span><a name="line-62"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Length</span><span> </span><a href="#local-1627754498"><span class="hs-identifier hs-type">os</span></a><span>
</span><a name="line-63"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Length</span><span> </span><a href="#local-1627754499"><span class="hs-identifier hs-type">ns</span></a><span>
</span><a name="line-64"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><span class="hs-special">(</span><a href="#local-1627754500"><span class="hs-identifier hs-type">ms</span></a><span>         </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754498"><span class="hs-identifier hs-type">os</span></a><span class="hs-special">)</span><span>
</span><a name="line-65"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Reverse</span><span> </span><a href="#local-1627754498"><span class="hs-identifier hs-type">os</span></a><span> </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754499"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">)</span><span>
</span><a name="line-66"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><span class="hs-special">(</span><a href="#local-1627754500"><span class="hs-identifier hs-type">ms</span></a><span>         </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754499"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">)</span><span>
</span><a name="line-67"></a><span>    </span><span class="hs-comment">-- is a list really the best data structure here?</span><span>
</span><a name="line-68"></a><span>    </span><span class="hs-comment">-- maybe Foldable f?</span><span>
</span><a name="line-69"></a><span>    </span><span class="hs-identifier">sumT</span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><a href="#local-1627754501"><span class="hs-identifier hs-type">o</span></a><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754501"><span class="hs-identifier hs-type">o</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754501"><span class="hs-identifier hs-type">o</span></a><span>
</span><a name="line-70"></a><span>    </span><span class="hs-identifier">scaleT</span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><a href="#local-1627754502"><span class="hs-identifier hs-type">o</span></a><span> </span><span class="hs-glyph">=&gt;</span><span> </span><a href="TensorOps.Types.html#ElemT"><span class="hs-identifier hs-type">ElemT</span></a><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754502"><span class="hs-identifier hs-type">o</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754502"><span class="hs-identifier hs-type">o</span></a><span>
</span><a name="line-71"></a><span>    </span><span class="hs-identifier">transp</span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">SingI</span><span> </span><a href="#local-1627754503"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Reverse</span><span> </span><a href="#local-1627754503"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-72"></a><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754503"><span class="hs-identifier hs-type">ns</span></a><span>
</span><a name="line-73"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Reverse</span><span> </span><a href="#local-1627754503"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">)</span><span>
</span><a name="line-74"></a><span>    </span><span class="hs-comment">-- sumRow  :: Remove ns n ms</span><span>
</span><a name="line-75"></a><span>    </span><span class="hs-comment">--         -&gt; t ns</span><span>
</span><a name="line-76"></a><span>    </span><span class="hs-comment">--         -&gt; t ms</span><span>
</span><a name="line-77"></a><span>    </span><span class="hs-identifier">mapRows</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><span class="hs-special">(</span><a href="#local-1627754504"><span class="hs-identifier hs-type">ns</span></a><span> </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754505"><span class="hs-identifier hs-type">ms</span></a><span class="hs-special">)</span><span>
</span><a name="line-78"></a><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier hs-type">Length</span><span> </span><a href="#local-1627754504"><span class="hs-identifier hs-type">ns</span></a><span>
</span><a name="line-79"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754505"><span class="hs-identifier hs-type">ms</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><a href="#local-1627754505"><span class="hs-identifier hs-type">ms</span></a><span class="hs-special">)</span><span>
</span><a name="line-80"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><span class="hs-special">(</span><a href="#local-1627754504"><span class="hs-identifier hs-type">ns</span></a><span> </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754505"><span class="hs-identifier hs-type">ms</span></a><span class="hs-special">)</span><span>
</span><a name="line-81"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627754495"><span class="hs-identifier hs-type">t</span></a><span> </span><span class="hs-special">(</span><a href="#local-1627754504"><span class="hs-identifier hs-type">ns</span></a><span> </span><span class="hs-operator">++</span><span> </span><a href="#local-1627754505"><span class="hs-identifier hs-type">ms</span></a><span class="hs-special">)</span><span>
</span><a name="line-82"></a><span>    </span><span class="hs-identifier">sumRows</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">SingI</span><span> </span><span class="hs-special">(</span><a href="#local-1627754506"><span class="hs-identifier hs-type">n</span></a><span> </span><span class="hs-char">': ns), SingI ns)
            =&gt; t (n ': ns)
            -&gt; t ns
    diag    :: SingI (n ': ns)
            =&gt; Uniform n ns
            -&gt; t '[n]
            -&gt; t (n ': ns)
    getDiag :: SingI n
            =&gt; Uniform n ns
            -&gt; t (n ': n ': ns)
            -&gt; t '[n]
    genRand :: (ContGen d, PrimMonad m, SingI ns)
            =&gt; d
            -&gt; Gen (PrimState m)
            -&gt; m (t ns)
    generateA :: (Applicative f, SingI ns)
              =&gt; (Prod (IndexN k) ns -&gt; f (ElemT t))
              -&gt; f (t ns)
    ixRows
        :: (Applicative f, SingI (ms ++ os))
        =&gt; Length ms
        -&gt; Length os
        -&gt; (Prod (IndexN k) ms -&gt; t ns -&gt; f (t os))
        -&gt; t (ms ++ ns)
        -&gt; f (t (ms ++ os))
    (!) :: t ns
        -&gt; Prod (IndexN k) ns
        -&gt; ElemT t

-- type TensorOp = OpPipe TOp

-- | Function and gradient
data VFunc n
    = VF { vfFunc :: !(forall a. RealFloat a =&gt; Vec n a -&gt; a      )
         , vfGrad :: !(forall a. RealFloat a =&gt; Vec n a -&gt; Vec n a)
         }

-- -- | A kludge to get around lack of impredicative types in Haskell
-- newtype VFunc n = VF { getVF :: forall a. RealFloat a =&gt; Vec n a -&gt; a }

data TOp :: [[k]] -&gt; [[k]] -&gt; Type where
    TOp :: { runTOp   :: !(forall t. (Tensor t, RealFloat (ElemT t)) =&gt; Prod t ns -&gt; Prod t ms)
           , gradTOp' :: !(forall t. (Tensor t, RealFloat (ElemT t)) =&gt; Prod t ns -&gt; Prod t ms -&gt; Prod t ns)
           } -&gt; TOp ns ms

gradTOp
    :: (Tensor t, RealFloat (ElemT t))
    =&gt; TOp ns '[ '[] ]
    -&gt; Prod t ns
    -&gt; Prod t ns
gradTOp o xs = gradTOp' o xs (only (getI $ generateA (\_ -&gt; I 1)))


instance Category TOp where
    id = TOp id
             (flip const)
    {-# INLINE id #-}

    (.) :: forall as bs cs. ()
        =&gt; TOp bs cs
        -&gt; TOp as bs
        -&gt; TOp as cs
    TOp f2 g2 . TOp f1 g1 = TOp f3 g3
      where
        f3  :: forall t. (Tensor t, RealFloat (ElemT t))
            =&gt; Prod t as
            -&gt; Prod t cs
        f3 = f2 . f1
        {-# INLINE f3 #-}
        g3  :: forall t. (Tensor t, RealFloat (ElemT t))
            =&gt; Prod t as
            -&gt; Prod t cs
            -&gt; Prod t as
        g3 xs ds = g1 xs (g2 (f1 xs) ds)
        {-# INLINE g3 #-}
    {-# INLINE (.) #-}

idOp
    :: forall ns. ()
    =&gt; TOp ns ns
idOp = id
{-# INLINE idOp #-}

firstOp
    :: forall os ns ms. (Known Length ns, Known Length ms)
    =&gt; TOp ns ms
    -&gt; TOp (ns ++ os) (ms ++ os)
firstOp (TOp f g) = TOp f' g'
  where
    f'  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t (ns ++ os)
        -&gt; Prod t (ms ++ os)
    f' = overProdInit @os known f
    {-# INLINE f' #-}
    g'  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t (ns ++ os)
        -&gt; Prod t (ms ++ os)
        -&gt; Prod t (ns ++ os)
    g' (takeProd @os known -&gt; xs) = overProdInit @os known (g xs)
    {-# INLINE g' #-}
{-# INLINE firstOp #-}

secondOp
    :: forall os ns ms. Known Length os
    =&gt; TOp ns ms
    -&gt; TOp (os ++ ns) (os ++ ms)
secondOp (TOp f g) = TOp f' g'
  where
    f'  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t (os ++ ns)
        -&gt; Prod t (os ++ ms)
    f' = overProdTail @os known f
    {-# INLINE f' #-}
    g'  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t (os ++ ns)
        -&gt; Prod t (os ++ ms)
        -&gt; Prod t (os ++ ns)
    g' (dropProd @os known -&gt; xs) = overProdTail @os known (g xs)
    {-# INLINE g' #-}
{-# INLINE secondOp #-}


(*&gt;&gt;)
    :: forall as bs cs ds. (Known Length as, Known Length bs)
    =&gt; TOp as bs
    -&gt; TOp (bs ++ cs) ds
    -&gt; TOp (as ++ cs) ds
t1 *&gt;&gt; t2 = firstOp @cs t1 &gt;&gt;&gt; t2
infixr 0 *&gt;&gt;
{-# INLINE (*&gt;&gt;) #-}

(&lt;&lt;*)
    :: forall as bs cs ds. (Known Length as, Known Length bs)
    =&gt; TOp (bs ++ cs) ds
    -&gt; TOp as bs
    -&gt; TOp (as ++ cs) ds
(&lt;&lt;*) = flip ((*&gt;&gt;) @as @bs @cs @ds)
infixr 2 &lt;&lt;*
{-# INLINE (&lt;&lt;*) #-}

(***)
    :: forall as bs cs ds. (Known Length as, Known Length cs)
    =&gt; TOp as cs
    -&gt; TOp bs ds
    -&gt; TOp (as ++ bs) (cs ++ ds)
TOp f1 g1 *** TOp f2 g2 = TOp f3 g3
  where
    f3  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t (as ++ bs)
        -&gt; Prod t (cs ++ ds)
    f3 = overProdSplit known f1 f2
    {-# INLINE f3 #-}
    g3  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t (as ++ bs)
        -&gt; Prod t (cs ++ ds)
        -&gt; Prod t (as ++ bs)
    g3 (splitProd known-&gt;(xs, ys)) = overProdSplit known (g1 xs) (g2 ys)
    {-# INLINE g3 #-}
{-# INLINE (***) #-}

(&amp;&amp;&amp;)
    :: forall as bs cs. (Known Length bs, SingI as)
    =&gt; TOp as bs
    -&gt; TOp as cs
    -&gt; TOp as (bs ++ cs)
TOp f1 g1 &amp;&amp;&amp; TOp f2 g2 = TOp f3 g3
  where
    f3  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t as
        -&gt; Prod t (bs ++ cs)
    f3 = TCP.append' &lt;$&gt; f1 &lt;*&gt; f2
    {-# INLINE f3 #-}
    g3  :: forall t. (Tensor t, RealFloat (ElemT t))
        =&gt; Prod t as
        -&gt; Prod t (bs ++ cs)
        -&gt; Prod t as
    g3 xs (splitProd known-&gt;(dtdys,dtdzs)) =
        zipProdWith3 (\s gxy gxz -&gt; sumT [gxy,gxz] \\ s)
                     (singProd sing)
                     (g1 xs dtdys)
                     (g2 xs dtdzs)
    {-# INLINE g3 #-}
{-# INLINE (&amp;&amp;&amp;) #-}


-- -- | TODO: replace with `syntactic`?
-- data OpPipe :: ([k] -&gt; [k] -&gt; Type) -&gt; [k] -&gt; [k] -&gt; Type where
--     OP&#216;   :: OpPipe f a a
--     Pop   :: !(Sing a)
--           -&gt; !(Sing b)
--           -&gt; !(Sing d)
--           -&gt; !(f a b)
--           -&gt; !(OpPipe f (b ++ d) c)
--           -&gt; OpPipe f (a ++ d) c

-- pappend
--     :: forall a b c d f. ()
--     =&gt; Sing a
--     -&gt; Sing b
--     -&gt; Sing d
--     -&gt; OpPipe f a b
--     -&gt; OpPipe f (b ++ d) c
--     -&gt; OpPipe f (a ++ d) c
-- pappend _ sB sD = \case
--     OP&#216; -&gt; id
--     Pop (sA' :: Sing a')
--         (sB' :: Sing b')
--         (sD' :: Sing d')
--         (x   :: f a' b'  )
--         (xs  :: OpPipe f (b' ++ d') b)
--           -&gt; \ys -&gt; let lD' :: Length d'
--                         lD' = singLength sD'
--                     in  Pop sA' sB' (sD' %:++ sD) x (pappend (sB' %:++ sD') sB sD xs ys)
--                           \\ appendAssoc (singLength sA') lD' lD
--                           \\ appendAssoc (singLength sB') lD' lD
--   where
--     lD :: Length d
--     lD = singLength sD

-- pipe
--     :: forall t a b. (SingI a, SingI b)
--     =&gt; t a b
--     -&gt; OpPipe t a b
-- pipe o = Pop sing sing SNil o OP&#216;
--            \\ appendNil (singLength (sing :: Sing a))
--            \\ appendNil (singLength (sing :: Sing b))

-- pop :: forall a b c d f. (SingI a, SingI b, SingI d)
--     =&gt; Length d
--     -&gt; f a b
--     -&gt; OpPipe f (b ++ d) c
--     -&gt; OpPipe f (a ++ d) c
-- pop _ = Pop (sing :: Sing a) (sing :: Sing b) (sing :: Sing d)

-- infixr 4 ~.
-- (~.)
--     :: (SingI a, SingI b, SingI d)
--     =&gt; (Length a, Length d, f a b)
--     -&gt; OpPipe f (b ++ d) c
--     -&gt; OpPipe f (a ++ d) c
-- (_, lD, x) ~. y = pop lD x y

instance Eq1 Finite
</span></pre></body></html>