<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DataKinds           #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts    #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE GADTs               #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase          #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE PolyKinds           #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes          #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications    #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators       #-}</span><span>
</span><a name="line-11"></a><span>
</span><a name="line-12"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">TOp</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-13"></a><span>
</span><a name="line-14"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Category</span><span>
</span><a name="line-15"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Foldable</span><span>
</span><a name="line-16"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Proxy</span><span>
</span><a name="line-17"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-18"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span>
</span><a name="line-19"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Conjunction</span><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Index</span><span>
</span><a name="line-21"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Length</span><span>                </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCL</span><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Length.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Length</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>           </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCL</span><span>
</span><a name="line-23"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCP</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">toList</span><span class="hs-special">)</span><span>
</span><a name="line-24"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Product.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>
</span><a name="line-25"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Sing.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Sing</span></a><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Uniform.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Uniform</span></a><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>                </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCV</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">AD</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Prelude</span><span> </span><span class="hs-keyword">hiding</span><span>                  </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">replicate</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">zip</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">negate</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">.</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">id</span><span class="hs-special">)</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><a href="TensorOps.Types.html"><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">T</span><span> </span><span class="hs-keyword">hiding</span><span>     </span><span class="hs-special">(</span><a href="TensorOps.Types.html#gmul"><span class="hs-identifier hs-var">gmul</span></a><span class="hs-special">)</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Higher</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Witness</span><span> </span><span class="hs-keyword">hiding</span><span>       </span><span class="hs-special">(</span><span class="hs-identifier hs-var">inner</span><span class="hs-special">)</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span>           </span><a href="Type.Family.List.Util.html"><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Data.Type.Product.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>          </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCP</span><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="TensorOps.Tensor.html"><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">Tensor</span></a><span>                </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TT</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="TensorOps.Types.html"><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span></a><span>                 </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">T</span><span>
</span><a name="line-39"></a><span>
</span><a name="line-40"></a><span class="hs-comment">-- | Lift any `R^N -&gt; R^M` function over every element in a n-tensor list,</span><span>
</span><a name="line-41"></a><span class="hs-comment">-- producing a m-tensor list.</span><span>
</span><a name="line-42"></a><span class="hs-identifier">liftOp</span><span>
</span><a name="line-43"></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><a href="#local-1627872512"><span class="hs-identifier hs-type">o</span></a><span>
</span><a name="line-44"></a><span>    </span><span class="hs-glyph">=&gt;</span><span> </span><a href="Data.Type.Uniform.html#Uniform"><span class="hs-identifier hs-type">Uniform</span></a><span> </span><a href="#local-1627872512"><span class="hs-identifier hs-type">o</span></a><span> </span><a href="#local-1627872513"><span class="hs-identifier hs-type">ns</span></a><span>
</span><a name="line-45"></a><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><a href="TensorOps.Types.html#VFunc"><span class="hs-identifier hs-type">VFunc</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Len</span><span> </span><a href="#local-1627872513"><span class="hs-identifier hs-type">ns</span></a><span class="hs-special">)</span><span>
</span><a name="line-46"></a><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><a href="TensorOps.Types.html#TOp"><span class="hs-identifier hs-type">TOp</span></a><span> </span><a href="#local-1627872513"><span class="hs-identifier hs-type">ns</span></a><span> </span><span class="hs-char">'[o]
liftOp = \case
    U&#216; -&gt; \f -&gt;
      TOp (\_   -&gt; only . TT.konst $ vfFunc f &#216;V)
          (\_ _ -&gt; &#216;                            )
    n@(US _) -&gt; \f -&gt;
        TOp (only . liftT (vfFunc f) . prodToVec I n)
            (\x -&gt; vecToProd getI n . TT.gradLift f (prodToVec I n x) . TCP.head')
{-# INLINE liftOp #-}

gmul
    :: forall ms os ns. (SingI (Reverse os ++ ns), SingI (ms ++ ns), SingI (ms ++ os))
    =&gt; Length ms
    -&gt; Length os
    -&gt; Length ns
    -&gt; TOp '[ (ms ++ os), (Reverse os ++ ns) ] '[ ms ++ ns ]
gmul lM lO lN = TOp f g
  where
    f   :: Tensor t
        =&gt; Prod t '[ (ms ++ os), (Reverse os ++ ns) ]
        -&gt; Prod t '[ ms ++ ns ]
    f = \case
      x :&lt; y :&lt; &#216; -&gt; only $ T.gmul lM lO lN x y
    g   :: Tensor t
        =&gt; Prod t '[ (ms ++ os), (Reverse os ++ ns) ]
        -&gt; Prod t '[ ms ++ ns ]
        -&gt; Prod t '[ (ms ++ os), (Reverse os ++ ns) ]
    g = \case
      x :&lt; y :&lt; &#216; -&gt; \case
        dtdz :&lt; &#216; -&gt; let rlO = TCL.reverse' lO
                         entailCatRev
                                :: p a
                                -&gt; p b
                                -&gt; (SingI (a ++ b) :- SingI (Reverse (a ++ b)))
                         entailCatRev _ _ = entailSing sReverse
                     in  (T.gmul lM lN lO dtdz (transp y)
                           \\ reverseConcat rlO lN
                           \\ reverseReverse lO
                           \\ entailCatRev rlO lN
                         )
                      :&lt; (T.gmul rlO (TCL.reverse' lM) lN
                               (transp x)
                               dtdz
                            \\ reverseConcat lM lO
                            \\ reverseReverse lM
                            \\ entailCatRev lM lO
                         )
                      :&lt; &#216;
{-# INLINE gmul #-}

-- TODO: allow for arbitrary permutation
transpOp
    :: forall ns. (SingI ns, SingI (Reverse ns))
    =&gt; Length ns
    -&gt; TOp '[ns] '[Reverse ns]
transpOp lN = TOp (only . transp . TCP.head')
                  (\_ -&gt; only . transp . TCP.head')
    \\ reverseReverse lN
{-# INLINE transpOp #-}

shuffle
    :: forall ns ms. SingI ns
    =&gt; Prod (Index ns) ms
    -&gt; TOp ns ms
shuffle is = TOp (TCP.select is) (\_ -&gt; gr)
  where
    gr  :: forall t. Tensor t
        =&gt; Prod t ms
        -&gt; Prod t ns
    gr dtdz = imap1 (\i s -&gt; f i \\ s) (singProd sing)
      where
        ixds :: Prod (Index ns :&amp;: t) ms
        ixds = zipProd is dtdz
        f  :: forall n. SingI n
           =&gt; Index ns n
           -&gt; t n
        f i = sumT . foldMap1 g $ ixds
          where
            g :: forall m. ()
              =&gt; (Index ns :&amp;: t) m
              -&gt; [t n]
            g (k :&amp;: d) = case testEquality k i of
              Just Refl -&gt; [d]
              Nothing   -&gt; []
    {-# INLINE gr #-}
{-# INLINE shuffle #-}

shuffleF
    :: forall ns ms. ()
    =&gt; (forall f. Prod f ns -&gt; Prod f ms)
    -&gt; (forall f. Prod f ms -&gt; Prod f ns)
    -&gt; TOp ns ms
shuffleF f g = TOp f (\_ -&gt; g)
{-# INLINE shuffleF #-}

shuffleF'
    :: forall ns ms. SingI ns
    =&gt; (forall f. Prod f ns -&gt; Prod f ms)
    -&gt; (forall f. Prod f ms -&gt; Prod ([] :.: f) ns)
    -&gt; TOp ns ms
shuffleF' f g = TOp f $ \_ -&gt;
    zipProdWith (\s (Comp xs) -&gt; sumT xs \\ s) (singProd sing)
  . g
{-# INLINE shuffleF' #-}

sumRows
    :: forall n ns. (SingI n, SingI ns)
    =&gt; TOp '[ n ': ns ] '[ ns ]
sumRows = TOp (only . T.sumRows . TCP.head')
              (\case
                  x :&lt; &#216; -&gt; \case
                    dtdz :&lt; &#216; -&gt; only $ mapRows (LS LZ) (\_ -&gt; dtdz) x
              )
{-# INLINE sumRows #-}

sumOp
    :: SingI n
    =&gt; Uniform n ns
    -&gt; TOp ns '[n]
sumOp u = TOp (only . sumT . toList . prodToVec I u)
              (\xs -&gt; \case
                  dtdz :&lt; &#216; -&gt; mapUniform u (\_ -&gt; dtdz) xs
              )
{-# INLINE sumOp #-}

scale
    :: SingI ns
    =&gt; (forall a. RealFloat a =&gt; a)
    -&gt; TOp '[ ns ] '[ ns ]
scale &#945; = TOp (only . scaleT &#945; . TCP.head')
              (\_ -&gt; only . scaleT &#945; . TCP.head')
{-# INLINE scale #-}

-- first
--     :: forall os ns ms. (Known Length ns, Known Length ms)
--     =&gt; TOp ns ms
--     -&gt; TOp (ns ++ os) (ms ++ os)
-- first = (*** idOp @os)

konst
    :: forall n ns. SingI n
    =&gt; Uniform n ns
    -&gt; (forall a. RealFloat a =&gt; a)
    -&gt; TOp '[] ns
konst u x = TOp (\_ -&gt; TCP.replicate (TT.konst x) u)
                (\_ _ -&gt; &#216;)
{-# INLINE konst #-}

negate :: SingI ns =&gt; TOp '[ns] '[ns]
negate = scale (-1)
{-# INLINE negate #-}

map' :: SingI n
      =&gt; (forall a. RealFloat a =&gt; a -&gt; a)
     -&gt; (forall a. RealFloat a =&gt; a -&gt; a)
     -&gt; TOp '[n] '[n]
map' f f' = liftOp (US U&#216;)
                   (VF (f . getI . TCV.head')
                       ((:+ &#216;V) . f' . getI . TCV.head')
                   )
{-# INLINE map' #-}


map :: SingI n
    =&gt; (forall a. RealFloat a =&gt; a -&gt; a)
    -&gt; TOp '[n] '[n]
map f = map' f (diff f)
{-# INLINE map #-}

add :: SingI n
    =&gt; TOp '[ n, n ] '[ n ]
add = TOp (\case x :&lt; y :&lt; &#216; -&gt; only $ sumT [x,y])
          (\_ -&gt; \case
            dtdz :&lt; &#216; -&gt; dtdz :&lt; dtdz :&lt; &#216;
          )
{-# INLINE add #-}

add3 :: SingI n
     =&gt; TOp '[ n, n, n ] '[ n ]
add3 = TOp (\case x :&lt; y :&lt; z :&lt; &#216; -&gt; only $ sumT [x,y,z])
           (\_ -&gt; \case
             dtdz :&lt; &#216; -&gt; dtdz :&lt; dtdz :&lt; dtdz :&lt; &#216;
           )
{-# INLINE add3 #-}


zipN'
    :: SingI n
    =&gt; Uniform n ns
    -&gt; (forall a. RealFloat a =&gt; Vec (Len ns) a -&gt; a)
    -&gt; (forall a. RealFloat a =&gt; Vec (Len ns) a -&gt; Vec (Len ns) a)
    -&gt; TOp ns '[n]
zipN' u f f' = liftOp u (VF f f')
{-# INLINE zipN' #-}

zipN
    :: SingI n
    =&gt; Uniform n ns
    -&gt; (forall a. RealFloat a =&gt; Vec (Len ns) a -&gt; a)
    -&gt; TOp ns '[n]
zipN u f = zipN' u f (grad f)
{-# INLINE zipN #-}

zip'
    :: SingI n
    =&gt; (forall a. RealFloat a =&gt; a -&gt; a -&gt; a)
    -&gt; (forall a. RealFloat a =&gt; a -&gt; a -&gt; (a, a))
    -&gt; TOp '[ n, n ] '[ n ]
zip' f f' = zipN' (US (US U&#216;)) (\case I x :* I y :* &#216;V -&gt; f x y)
                               (\case I x :* I y :* &#216;V -&gt;
                                        let (dx, dy) = f' x y
                                        in  dx :+ dy :+ &#216;V
                               )
{-# INLINE zip' #-}

zip
    :: SingI n
    =&gt; (forall a. RealFloat a =&gt; a -&gt; a -&gt; a)
    -&gt; TOp '[ n, n ] '[ n ]
zip f = zipN (US (US U&#216;)) (\case I x :* I y :* &#216;V -&gt; f x y)
{-# INLINE zip #-}

zip3'
    :: SingI n
    =&gt; (forall a. RealFloat a =&gt; a -&gt; a -&gt; a -&gt; a)
    -&gt; (forall a. RealFloat a =&gt; a -&gt; a -&gt; a -&gt; (a, a, a))
    -&gt; TOp '[ n, n, n ] '[ n ]
zip3' f f' = zipN' (US (US (US U&#216;))) (\case I x :* I y :* I z :* &#216;V -&gt; f x y z)
                                     (\case I x :* I y :* I z :* &#216;V -&gt;
                                              let (dx, dy, dz) = f' x y z
                                              in  dx :+ dy :+ dz :+ &#216;V
                                     )
{-# INLINE zip3' #-}

zip3
    :: SingI n
    =&gt; (forall a. RealFloat a =&gt; a -&gt; a -&gt; a -&gt; a)
    -&gt; TOp '[ n, n, n ] '[ n ]
zip3 f = zipN (US (US (US U&#216;))) (\case I x :* I y :* I z :* &#216;V -&gt; f x y z)
{-# INLINE zip3 #-}

replicate
    :: SingI n
    =&gt; Uniform n ns
    -&gt; TOp '[ n ] ns
replicate u = TOp (flip TCP.replicate u . TCP.head')
                  (\_ -&gt; only . sumT . toList . prodToVec I u)
{-# INLINE replicate #-}

duplicate
    :: SingI n
    =&gt; TOp '[ n ] '[ n, n ]
duplicate = TOp (\case x :&lt; &#216; -&gt; x :&lt; x :&lt; &#216;)
                (\_ -&gt; \case
                    d1 :&lt; d2 :&lt; &#216; -&gt; only $ sumT [d1, d2]
                )
{-# INLINE duplicate #-}

inner
    :: forall ms ns o. (SingI (o ': ns), SingI (ms &gt;: o), SingI (ms ++ ns))
    =&gt; Length ms
    -&gt; Length ns
    -&gt; TOp '[ms &gt;: o, o ': ns] '[ ms ++ ns ]
inner lM lN = gmul lM (LS LZ) lN
                \\ appendSnoc lM (Proxy @o)
{-# INLINE inner #-}

outer
    :: (SingI ms, SingI ns, SingI (ms ++ ns))
    =&gt; Length ms
    -&gt; Length ns
    -&gt; TOp '[ms, ns] '[ ms ++ ns ]
outer lM lN = gmul lM LZ lN
                \\ appendNil lM
{-# INLINE outer #-}

dot :: SingI m
    =&gt; TOp '[ '[m], '[m] ] '[ '[] ]
dot = inner LZ LZ
{-# INLINE dot #-}

matVec
    :: (SingI m, SingI n)
    =&gt; TOp '[ '[m,n], '[n] ] '[ '[m] ]
matVec = inner (LS LZ) LZ
{-# INLINE matVec #-}

vecMat
    :: (SingI m, SingI n)
    =&gt; TOp '[ '[m], '[m,n] ] '[ '[n] ]
vecMat = inner LZ (LS LZ)
{-# INLINE vecMat #-}

matMat
    :: (SingI m, SingI n, SingI o)
    =&gt; TOp '[ '[m,n], '[n,o] ] '[ '[m,o] ]
matMat = inner (LS LZ) (LS LZ)
{-# INLINE matMat #-}


swap :: TOp '[ms,ns] '[ns,ms]
swap = TOp (\case x :&lt; y :&lt; &#216; -&gt; y :&lt; x :&lt; &#216;)
           (\_ -&gt; \case
              d1 :&lt; d2 :&lt; &#216; -&gt; d2 :&lt; d1 :&lt; &#216;
           )
{-# INLINE swap #-}

swap'
    :: forall ns ms. ()
    =&gt; Length ns
    -&gt; Length ms
    -&gt; TOp (ns ++ ms) (ms ++ ns)
swap' lN lM = shuffleF (swapProd @ns @ms lN)
                       (swapProd @ms @ns lM)
{-# INLINE swap' #-}

drop
    :: forall ms ns. SingI (ns ++ ms)
    =&gt; Length ns
    -&gt; TOp (ns ++ ms) ms
drop lN = shuffleF' (dropProd lN)
                    ( (pgen lN (\_ -&gt; Comp []) `TCP.append'`)
                    . map1 (Comp . (:[]))
                    )
{-# INLINE drop #-}

take
    :: forall ns ms. SingI (ns ++ ms)
    =&gt; Length ns
    -&gt; Length ms
    -&gt; TOp (ns ++ ms) ns
take lN lM = shuffleF' (takeProd @ms lN)
                       ( (`TCP.append'` pgen lM (\_ -&gt; Comp []))
                       . map1 (Comp . (:[]))
                       )
{-# INLINE take #-}

</span></pre></body></html>