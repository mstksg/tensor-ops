<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DataKinds           #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts    #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE GADTs               #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE KindSignatures      #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase          #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes          #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications    #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE TypeInType          #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators       #-}</span><span>
</span><a name="line-12"></a><span>
</span><a name="line-13"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">Learn</span><span class="hs-operator">.</span><span class="hs-identifier">NeuralNet</span><span class="hs-operator">.</span><span class="hs-identifier">Recurrent</span><span>
</span><a name="line-14"></a><span>  </span><span class="hs-special">(</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#Network"><span class="hs-identifier hs-type">Network</span></a><span>
</span><a name="line-15"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#buildNet"><span class="hs-identifier hs-var">buildNet</span></a><span>
</span><a name="line-16"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#netParams"><span class="hs-identifier hs-var">netParams</span></a><span>
</span><a name="line-17"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#runNetwork"><span class="hs-identifier hs-var">runNetwork</span></a><span>
</span><a name="line-18"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#runNetworkSt"><span class="hs-identifier hs-var">runNetworkSt</span></a><span>
</span><a name="line-19"></a><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#~%2A~"><span class="hs-operator hs-var">~*~</span></a><span class="hs-special">)</span><span>
</span><a name="line-20"></a><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#%2A~"><span class="hs-operator hs-var">*~</span></a><span class="hs-special">)</span><span>
</span><a name="line-21"></a><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#~%2A"><span class="hs-operator hs-var">~*</span></a><span class="hs-special">)</span><span>
</span><a name="line-22"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#nmap"><span class="hs-identifier hs-var">nmap</span></a><span>
</span><a name="line-23"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#trainNetwork"><span class="hs-identifier hs-var">trainNetwork</span></a><span>
</span><a name="line-24"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="TensorOps.Learn.NeuralNet.Recurrent.html#networkGradient"><span class="hs-identifier hs-var">networkGradient</span></a><span>
</span><a name="line-25"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-26"></a><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Category</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">.</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">id</span><span class="hs-special">)</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">DeepSeq</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">State</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Kind</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Conjunction</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Length</span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCL</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Length.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Length</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCL</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span>       </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCP</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Product.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCP</span><span>
</span><a name="line-39"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Sing.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Sing</span></a><span>
</span><a name="line-40"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Uniform.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Uniform</span></a><span>
</span><a name="line-41"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCV</span><span>
</span><a name="line-42"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Vector.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCV</span><span>
</span><a name="line-43"></a><span class="hs-keyword">import</span><span>           </span><a href="TensorOps.TOp.html"><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">TOp</span></a><span>           </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TO</span><span>
</span><a name="line-44"></a><span class="hs-keyword">import</span><span>           </span><a href="TensorOps.Tensor.html"><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">Tensor</span></a><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TT</span><span>
</span><a name="line-45"></a><span class="hs-keyword">import</span><span>           </span><a href="TensorOps.Types.html"><span class="hs-identifier">TensorOps</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span></a><span>
</span><a name="line-46"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Higher</span><span>
</span><a name="line-47"></a><span class="hs-keyword">import</span><span>           </span><a href="Type.Class.Higher.Util.html"><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Higher</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>
</span><a name="line-48"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Known</span><span>
</span><a name="line-49"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Witness</span><span>
</span><a name="line-50"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-51"></a><span class="hs-keyword">import</span><span>           </span><a href="Type.Family.List.Util.html"><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>
</span><a name="line-52"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>
</span><a name="line-53"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Unsafe</span><span class="hs-operator">.</span><span class="hs-identifier">Coerce</span><span>
</span><a name="line-54"></a><span>
</span><a name="line-55"></a><span class="hs-keyword">data</span><span> </span><a name="Network"><a href="TensorOps.Learn.NeuralNet.Recurrent.html#Network"><span class="hs-identifier">Network</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><a href="#local-1627968237"><span class="hs-identifier hs-type">k</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627968237"><span class="hs-identifier hs-type">k</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627968237"><span class="hs-identifier hs-type">k</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-56"></a><span>    </span><a name="N"><a href="TensorOps.Learn.NeuralNet.Recurrent.html#N"><span class="hs-identifier">N</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">{</span><span> </span><a name="_nsSs"><a href="TensorOps.Learn.NeuralNet.Recurrent.html#_nsSs"><span class="hs-identifier">_nsSs</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="hs-identifier hs-type">Sing</span><span> </span><a href="#local-1627968238"><span class="hs-identifier hs-type">ss</span></a><span class="hs-special">)</span><span>
</span><a name="line-57"></a><span>         </span><span class="hs-special">,</span><span> </span><a name="_nsPs"><a href="TensorOps.Learn.NeuralNet.Recurrent.html#_nsPs"><span class="hs-identifier">_nsPs</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="hs-identifier hs-type">Sing</span><span> </span><a href="#local-1627968239"><span class="hs-identifier hs-type">ps</span></a><span class="hs-special">)</span><span>
</span><a name="line-58"></a><span>         </span><span class="hs-special">,</span><span> </span><a name="_nOp"><a href="TensorOps.Learn.NeuralNet.Recurrent.html#_nOp"><span class="hs-identifier">_nOp</span></a></a><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><a href="TensorOps.Types.html#TOp"><span class="hs-identifier hs-type">TOp</span></a><span> </span><span class="hs-special">(</span><span class="hs-char">'[i] ': ss ++ ps) ('[o] ': ss))
         , _nState  :: !(Prod t ss)
         , _nParams :: !(Prod t ps)
         } -&gt; Network t i o

instance NFData1 t =&gt; NFData (Network t i o) where
    rnf = \case
      N _ _ o p s -&gt; o `seq` p `deepseq1` s `deepseq1` ()
    {-# INLINE rnf #-}

netParams
    :: Network t i o
    -&gt; (forall ss ps. (SingI ss, SingI ps) =&gt; Prod t ss -&gt; Prod t ps -&gt; r)
    -&gt; r
netParams = \case
    N sS sP _ s p -&gt; \f -&gt; f s p \\ sS \\ sP

buildNet
    :: (SingI ss, SingI ps)
    =&gt; TOp ('[i] ': ss ++ ps) ('[o] ': ss)
    -&gt; Prod t ss
    -&gt; Prod t ps
    -&gt; Network t i o
buildNet = N sing sing

(~*~)
    :: forall k (t :: [k] -&gt; Type) a b c. ()
    =&gt; Network t a b
    -&gt; Network t b c
    -&gt; Network t a c
(~*~) = \case
  N (sSs1 :: Sing ss1)
    (sPs1 :: Sing ps1)
    (o1   :: TOp ('[a] ': ss1 ++ ps1) ('[b] ': ss1))
    (s1   :: Prod t ss1)
    (p1   :: Prod t ps1) -&gt; \case
    N (sSs2 :: Sing ss2)
      (sPs2 :: Sing ps2)
      (o2   :: TOp ('[b] ': ss2 ++ ps2) ('[c] ': ss2))
      (s2   :: Prod t ss2)
      (p2   :: Prod t ps2) -&gt;
      let lSs1 :: Length ss1
          lSs1 = singLength sSs1
          lSs2 :: Length ss2
          lSs2 = singLength sSs2
          lPs1 :: Length ps1
          lPs1 = singLength sPs1
          lPs2 :: Length ps2
          lPs2 = singLength sPs2
          o :: TOp ('[a] ': (ss2 ++ ss1) ++ (ps1 ++ ps2)) ('[c] ': ss2 ++ ss1)
                    -- all these proofs lol
          o     = (\\ (unsafeCoerce Refl :: ((ss2 ++ ss1) ++ ps1) ++ ps2 :~: (ss2 ++ ss1) ++ (ps1 ++ ps2))) $
                  (\\ (unsafeCoerce Refl :: ((ss1 ++ ps1) ++ ss2) ++ ps2 :~: (ss1 ++ ps1) ++ (ss2 ++ ps2))) $
                  (\\ appendAssoc lSs1 lSs2 lPs2                  ) $
                  (\\ appendAssoc lSs2 lSs1 lPs1                  ) $
                  (\\ (lSs2 `TCL.append'` lSs1) `TCL.append'` lPs1) $
                  (\\ (lSs1 `TCL.append'` lPs1) `TCL.append'` lSs2) $
                  (\\ lSs1                                        ) $
                  (\\ lSs2                                        ) $
                  (\\ lSs1 `TCL.append'` lPs1                     ) $
                  (\\ lSs2 `TCL.append'` lPs2                     ) $
                    secondOp @'[ '[a] ]
                      (firstOp @ps2 (TO.swap' lSs2 (lSs1 `TCL.append'` lPs1))
                      )
                &gt;&gt;&gt; firstOp @(ss2 ++ ps2) o1
                &gt;&gt;&gt; secondOp @'[ '[b] ] (TO.swap' lSs1 (lSs2 `TCL.append'` lPs2))
                &gt;&gt;&gt; firstOp @ss1 o2
      in  N (sSs2 %:++ sSs1)
            (sPs1 %:++ sPs2)
            o
            (s2 `TCP.append'` s1)
            (p1 `TCP.append'` p2)
infixr 4 ~*~
{-# INLINE (~*~) #-}

runNetwork
    :: (RealFloat (ElemT t), Tensor t)
    =&gt; Network t i o
    -&gt; t '[i]
    -&gt; (t '[o], Network t i o)
runNetwork (N sS sO o s p) x =
        (\case y :&lt; s' -&gt; (y, N sS sO o s' p))
      . runTOp o
      $ x :&lt; (s `TCP.append'` p)
{-# INLINE runNetwork #-}

runNetworkSt
    :: (RealFloat (ElemT t), Tensor t, MonadState (Network t i o) m)
    =&gt; t '[i]
    -&gt; m (t '[o])
runNetworkSt x = state $ flip runNetwork x

(~*) :: TOp '[ '[a] ] '[ '[b] ]
     -&gt; Network t b c
     -&gt; Network t a c
f ~* N sS sO o s p = N sS sO (f *&gt;&gt; o) s p
infixr 4 ~*
{-# INLINE (~*) #-}

(*~) :: Network t a b
     -&gt; TOp '[ '[b] ] '[ '[c] ]
     -&gt; Network t a c
N sS sO o s p *~ f = N sS sO (o &gt;&gt;&gt; firstOp f) s p
infixl 5 *~
{-# INLINE (*~) #-}

nmap
     :: SingI o
     =&gt; (forall a. RealFloat a =&gt; a -&gt; a)
     -&gt; Network t i o
     -&gt; Network t i o
nmap f n = n *~ TO.map f
{-# INLINE nmap #-}

netGrad
    :: forall k n (t :: [k] -&gt; Type) (i :: k) (o :: k) ss ps.
     ( Tensor t
     , RealFloat (ElemT t)
     , SingI i
     , SingI o
     )
    =&gt; TOp '[ '[o], '[o] ] '[ ('[] :: [k]) ]
    -&gt; Vec n (t '[i])
    -&gt; Vec n (t '[o])
    -&gt; Sing ss
    -&gt; Sing ps
    -&gt; TOp ('[i] ': ss ++ ps) ('[o] ': ss)
    -&gt; Prod t ss
    -&gt; Prod t ps
    -&gt; (Vec n (t '[i]), (Prod t ss, Prod t ps))
netGrad loss xs ys sS sP o s p =
      (prodToVec' I n grI, splitProd @ps lS grSP)
  where
    n :: Nat n
    n = known   \\ xs
    lS :: Length ss
    lS = singLength sS
    lP :: Length ps
    lP = singLength sP
    sO :: Sing (Replicate n '[o])
    sO = replicateSing (sing :: Sing '[o]) n
    lI :: Length (Replicate n '[i])
    lI = replicateLength @'[i] n
    lO :: Length (Replicate n '[o])
    lO = replicateLength @'[o] n
    unrolled
        :: TOp (Replicate n '[i] ++ ss ++ ps) (Replicate n '[o])
    unrolled = (\\ sS %:++ sO) $
               (\\ sS %:++ sP) $
                 unroll sS sP o n
             &gt;&gt;&gt; TO.drop @(Replicate n '[o]) lS
    o'  :: TOp (Replicate n '[i] ++ ss ++ ps ++ Replicate n '[o]) '[ '[] ]
    o' = (\\ appendAssoc lI (lS `TCL.append'` lP) lO) $
         (\\ appendAssoc lS lP lO) $
         (\\ lI `TCL.append'` lS `TCL.append'` lP) $
         (\\ lO) $
            firstOp @(Replicate n '[o]) unrolled
        &gt;&gt;&gt; rollup @k lS lP loss n
    xs' :: Prod t (Replicate n '[i] ++ ss ++ ps ++ Replicate n '[o])
    xs' = vecToProd' getI (TCV.reverse' xs) `TCP.append'` (s
            `TCP.append'` (
              p `TCP.append'` vecToProd' getI ys
            )
          )
    grad :: Prod t (Replicate n '[i] ++ ss ++ ps)
    grad = (\\ (unsafeCoerce Refl :: Replicate n '[i] ++ ss ++ ps ++ Replicate n '[o]
                                 :~: (Replicate n '[i] ++ ss ++ ps) ++ Replicate n '[o]
               )
           ) $
      takeProd @(Replicate n '[o]) (lI `TCL.append'` lS `TCL.append'` lP) $ gradTOp o' xs'
    grI   :: Prod t (Replicate n '[i])
    grSP  :: Prod t (ss ++ ps)
    (grI, grSP) = splitProd @(ss ++ ps) lI grad
{-# INLINE netGrad #-}

trainNetwork
    :: forall k n (t :: [k] -&gt; Type) (i :: k) (o :: k).
     ( Tensor t
     , RealFloat (ElemT t)
     , SingI i
     , SingI o
     )
    =&gt; TOp '[ '[o], '[o] ] '[ ('[] :: [k]) ]
    -&gt; ElemT t
    -&gt; ElemT t
    -&gt; Vec n (t '[i])
    -&gt; Vec n (t '[o])
    -&gt; Network t i o
    -&gt; Network t i o
trainNetwork loss rS rP xs ys = \case
    N sS sP o s p -&gt;
      let (gS, gP) = snd $ netGrad loss xs ys sS sP o s p
          s' = map1 (f rS) $ zipProd3 (singProd sS) s gS
          p' = map1 (f rP) $ zipProd3 (singProd sP) p gP
      in  N sS sP o s' p'
  where
    f   :: forall ns. ()
        =&gt; ElemT t
        -&gt; (Sing :&amp;: t :&amp;: t) ns
        -&gt; t ns
    f r (s1 :&amp;: p1 :&amp;: g1) =
      TT.zip (\p2 g2 -&gt; p2 - r * g2) p1 g1 \\ s1
    {-# INLINE f #-}
{-# INLINE trainNetwork #-}

networkGradient
    :: forall k n (t :: [k] -&gt; Type) (i :: k) (o :: k) r.
     ( Tensor t
     , RealFloat (ElemT t)
     , SingI i
     , SingI o
     )
    =&gt; TOp '[ '[o], '[o] ] '[ ('[] :: [k]) ]
    -&gt; Vec n (t '[i])
    -&gt; Vec n (t '[o])
    -&gt; Network t i o
    -&gt; (forall ss ps. (SingI ss, SingI ps) =&gt; Vec n (t '[i]) -&gt; Prod t ss -&gt; Prod t ps -&gt; r)
    -&gt; r
networkGradient loss xs ys = \case
    N sS sP o s p -&gt; \f -&gt; case netGrad loss xs ys sS sP o s p of
      (gI, (gS, gP)) -&gt; f gI gS gP \\ sS \\ sP
{-# INLINE networkGradient #-}


unroll
    :: forall ss ps i o n. (SingI (ss ++ ps), SingI i)
    =&gt; Sing ss
    -&gt; Sing ps
    -&gt; TOp ('[i] ': ss ++ ps) ('[o] ': ss)
    -&gt; Nat n
    -&gt; TOp (Replicate n '[i] ++ ss ++ ps) (ss ++ Replicate n '[o])
unroll sS sP o = \case
    Z_              -&gt; TO.take lS lP    \\ appendNil lS
    S_ (m :: Nat m) -&gt; (\\ (unsafeCoerce Refl :: Replicate m '[i] ++ '[i] ': ss ++ ps
                                             :~: '[i] ': Replicate m '[i] ++ ss ++ ps
                           )
                       ) $
                       (\\ (unsafeCoerce Refl :: (Replicate m '[i] ++ ss ++ ps) ++ '[ '[o] ]
                                             :~: Replicate m '[i] ++ ss ++ (ps &gt;: '[o])
                           )
                       ) $
                       (\\ (unsafeCoerce Refl :: (ss ++ Replicate m '[o]) ++ '[ '[o] ]
                                             :~: ss ++ '[o] ': Replicate m '[o]
                           )
                       ) $
                       (\\ appendAssoc lS lP (LS LZ :: Length '[ '[o] ])) $
                       (\\ appendSnoc lP (Proxy @'[o])) $
                       (\\ replicateLength @'[i] m `TCL.append'` lS `TCL.append'` lP) $
                       (\\ lS `TCL.append'` replicateLength @'[o] m) $
                       (\\ replicateLength @'[i] m) $
                       (\\ lS) $
          secondOp @(Replicate m '[i]) @('[i] ': ss ++ ps) @(ss ++ ps &gt;: '[o]) (
                (o &amp;&amp;&amp; TO.drop @ps @('[i] ': ss) (LS lS))
            &gt;&gt;&gt; TO.swap' (LS LZ) (lS `TCL.append'` lP)
          )
      &gt;&gt;&gt; firstOp @'[ '[o] ] @(Replicate m '[i] ++ ss ++ ps) @(ss ++ Replicate m '[o]) (
            unroll sS sP o m
          )
  where
    lS :: Length ss
    lS = singLength sS
    lP :: Length ps
    lP = singLength sP
{-# INLINE unroll #-}


rollup
    :: forall k (ss :: [[k]]) (ps :: [[k]]) (o :: k) (n :: N). ()
    =&gt; Length ss
    -&gt; Length ps
    -&gt; TOp '[ '[o], '[o] ] '[ ('[] :: [k]) ]
    -&gt; Nat n
    -&gt; TOp (Replicate n '[o] ++ Replicate n '[o]) '[ ('[] :: [k]) ]
rollup lS lP loss = \case
    Z_                     -&gt; TO.konst (US U&#216;) 0
    S_ Z_                  -&gt; loss
    S_ (m@(S_ _) :: Nat m) -&gt;
      let lO :: Length (Replicate m '[o])
          lO = replicateLength @'[o] m
      in  (\\ (unsafeCoerce Refl :: Replicate m '[o] ++ '[o] ': '[o] ': Replicate m '[o]
                                :~: '[o] ': Replicate m '[o] ++ '[o] ': Replicate m '[o]
              )
            ) $
            (\\ appendSnoc lO (Proxy @'[])) $
            (\\ lO) $
            (\\ lO `TCL.append'` lO) $
            (\\ appendAssoc lO lO (LS LZ :: Length '[ '[] ])) $
              secondOp @(Replicate m '[o]) @('[o] ': '[o] ': Replicate m '[o]) @(Replicate m '[o] &gt;: '[]) (
                  firstOp @(Replicate m '[o]) @('[ '[o], '[o] ]) @('[ '[] ]) loss
                &gt;&gt;&gt; TO.swap' @'[ '[] ] @(Replicate m '[o]) (LS LZ) lO
              )
            &gt;&gt;&gt; firstOp @'[ '[] ] @(Replicate m '[o] ++ Replicate m '[o]) @'[ '[] ] (
                  rollup lS lP loss m
                )
            &gt;&gt;&gt; TO.add
{-# INLINE rollup #-}
</span></pre></body></html>